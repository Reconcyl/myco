Myco: Programming artificial life

Myco is a project aiming at creating mutating artificial life using a fungeoid programming language.

The idea is that the world is a two-dimensional grid of instructions. Organisms move around on this grid executing instructions and modifying them.

Each organism has access to the following state:

- An instruction pointer (to a location on the grid)
- A control flow flag
- A memory pointer (to a location on the grid)
- A selection radius (maximum 10)
- A clipboard (storing a odd-side-length square of instructions, maximum width 21)
- Two registers (ax and bx) storing bytes
- A data array storing bytes

Special:

end               @@
fork (flag)       -=
fork (ip = mp)    m=

Arithmetic instructions:

ax = 0           0a
bx = 0           0b
ax = bx          ab
bx = ax          ba
ax, bx = bx, ax  ::
ax = ax + bx     a+
bx = ax + bx     b+
ax = -ax         a-
bx = -bx         b-
ax = ax + 1      +a
bx = bx + 1      +b
ax = ax - 1      -a
bx = bx - 1      -b
ax = ax * bx     a*
bx = ax * bx     b*
ax = ax * 2      aa
bx = bx * 2      bb
ax = ax / 2      a/
bx = bx / 2      b/
ax = ax % 2      a%
bx = bx % 2      b%
ax = ax & bx     a&
bx = ax & bx     b&
ax = ax | bx     a|
bx = ax | bx     b|
ax = ax ^ bx     a^
bx = ax ^ bx     b^
ax = ax == bx    a=
bx = ax == bx    b=
ax = ax != bx    a!
bx = ax != bx    b!
ax = ax != 0     a1
bx = bx != 0     b1
ax = ax == 0     a0
bx = bx == 0     b0

Control flow:

wait ax              .a
wait bx              .b
dir = <              !<
dir = >              !>
dir = ^              !^
dir = v              !v
if (flag) dir = <    ?<
if (flag) dir = >    ?>
if (flag) dir = ^    ?^
if (flag) dir = v    ?v
dir reflect          !#
dir reflect |        !|
dir reflect -        !-
dir reflect /        !/
dir reflect \        !\
flag = true          ((
flag = false         ))
flag = ax == 0       (a
flag = ax != 0       )a
flag = bx == 0       (b
flag = bx != 0       )b
flag = ax == bx      (=
flag = ax != bx      )=
flag = !flag         )(
ax = flag            a(
bx = flag            b(

Data selection:

mp move <      #<
mp move >      #>
mp move ^      #^
mp move v      #v
mp move <*ax   a<
mp move >*ax   a>
mp move ^*ax   a^
mp move v*ax   av
mp move <*bx   b<
mp move >*bx   b>
mp move ^*bx   b^
mp move v*bx   bv
mp = ip        #0
mr = ax        ra
mr = bx        rb
mr = 1         r1
ax = mr        ar
bx = mr        br
mr ++          r+
mr --          r-

Clipboard:

cut            cx
copy           cm
paste          mc
swap           c:

Data array:

DP = ax     ]a
DP = bx     ]b
ax = DP     a]
bx = DP     b]
DP --       ]<
DP ++       ]>
DP += a     }a
DP -= a     }A
DP += b     }b
DP -= b     }B
[DP] = ax   [a
[DP] = bx   [b
ax = [DP]   a[
bx = [DP]   b[
[DP] ++     [+
[DP] --     [-
[DP] += a   {a
[DP] -= a   {A
[DP] += b   {b
[DP] -= b   {B